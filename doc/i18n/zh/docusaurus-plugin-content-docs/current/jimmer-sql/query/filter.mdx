---
sidebar_position: 9
title: 全局过滤器
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

在实际项目中，有一类需求很常见，例如

-   软删除

    业务层面的删除操作，并非对应于数据库的删除操作，而是为数据设置一个“已删除”的标记，绝大部分查询操作不查询有此状态的数据。这样，被标记为“已删除”的数据将会被屏蔽，直到“已删除”的状态被撤销为止。

-   多租户

    数据具备一个“所属租户”字段，如果系统的登陆信息也可以解析出“当前租户”，则利用“当前租户”过滤查询数据，从而让不同租户的访问者登陆后看到不同的数据。

-   数据授权

    数据可能通过某些和授权相关的关联，间接地和用户有关系。利用登陆身份，可以做到让每个用户仅能查询他被授权可以访问的数据。

以上这类需求，本质上是一样的，这是一种隐式地为查询植入where条件的诉求，Jimmer提供全局过滤器解决这个问题。

:::tip
如果读者熟悉Oracle数据库，可以用[VPD](https://docs.oracle.com/database/121/DBSEG/vpd.htm)来类比理解。Jimmer全局过滤器为所有数据库引入了类似于Oracle VPD的能力。
:::

以上这类需求中，多租户复杂度比较适中，本文以多租户为例，讲解全局过滤器。

:::note
在某些多租户系统中，不同租户的数据需要分表甚至分库存储。

如果有这方面的诉求，请结合[sharding-jdbc](https://shardingsphere.apache.org/document/4.1.1/en/manual/sharding-jdbc/)使用。在JDBC层面而非ORM层面解决分库分表的问题。
:::

## 提供过滤器

### 提供抽象实体基类

首先，提供一个`MappedSuperclass`超类，所有需要多租户管理的实体类都可以继承它

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@MappedSuperclass
public interface TenantAware {

    String tenant();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@MappedSuperclass
interface TenantAware {

    val tenant: String
}
```

</TabItem>
</Tabs>

### 提供过滤器

下面的示例中，`TenantProvider`类的Java方法`get()`和kotlin属性`tenant`用于返回当前操作着所属租户。

Java拦截器必须实现`org.babyfish.jimmer.sql.filter.Filter`接口，Kotlin拦截器必须实现`org.babyfish.jimmer.sql.kt.filter.KFilter`接口。

如果使用Spring托管，代码方式如下：

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Component
public class TenantFilter implements Filter<TenantAwareProps> {

    protected final TenantProvider tenantProvider;

    public TenantFilterForNonCacheMode(TenantProvider tenantProvider) {
        this.tenantProvider = tenantProvider;
    }

    @Override
    public void filter(FilterArgs<TenantAwareProps> args) {
        String tenant = tenantProvider.get();
        if (tenant != null) {
            args.where(args.getTable().tenant().eq(tenant));
        }
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Component
class TenantFilter(
    protected val tenantProvider: TenantProvider
) : KFilter<TenantAware> {

    override fun filter(args: KFilterArgs<TenantAware>) {
        tenantProvider.tenant?.let {
            args.apply {
                where(table.tenant.eq(it))
            }
        }
    }
}
```

</TabItem>
</Tabs>

`TenantFilter`首先从提取当前操作者的所属租户，如果所属租户部位null，则使用它来过滤数据，只查询和指定租户匹配的数据。

### 配置过滤器

将过滤器挂接到SqlClinet对象上，即可生效

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
@Bean
public JSqlClient sqlClient(
    List<Filter<?>> filters,
    ...省略其他参数...
) {
    return JSqlBuilder
        .newBuilder()
        // highlight-next-line
        .addFilters(filters)
        ...省略其他配置...
        .build();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
@Bean
fun sqlClient(
    filters: List<KFilter<?>>,
    ...省略其他参数...
): KSqlClient =
    newKSqlClient {
        // highlight-next-line
        addFilters(filters)
        ...省略其他配置...
    }
```

</TabItem>
</Tabs>

虽然在本文的中，仅示范了一个`Filter`/`KFilter`，实际项目中可能有很多个。

所以，这里使用集合，让Spring注入所有的`Filter`/`KFilter`。

## 过滤聚合根读对象

过滤聚合根对象是全局过滤器最简单的用法。

假设`Book`实体继承了`TenantAware`，用法如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Book> books = sqlClient.getEntities.findAll(Book.class);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient.entities.findAll(Book::class);
```

</TabItem>
</Tabs>
或
<Tabs groupId="language">
<TabItem value="java" label="Java(Fluent)">

```java
Fluent fluent = sqlClient.createFluent();
BookTable book = new BookTable();
List<Book> books = fluent
    .query(book)
    .select(book)
    .execute();
```

</TabItem>
<TabItem value="java-lamda" label="Java(Lambda)">

```java
List<Book> books = sqlClient
    .createQuery(BookTable.class, (q, book) -> {
        return q.select(book);
    })
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = SqlClient
    .createQuery(Book::class) {
        select(table)
    }
    .execute()
```

</TabItem>
</Tabs>

生成的SQL如下

```sql
select 
    tb_1_.ID, 
    tb_1_.TENANT, 
    tb_1_.NAME, 
    tb_1_.EDITION, 
    tb_1_.PRICE, 
    tb_1_.STORE_ID 
from BOOK as tb_1_
/* highlight-next-line */ 
where tb_1_.TENANT = ?
```

不难发现，这里使用了最简单的查询，没有任何查询参数。但是最终生产的SQL仍然过滤了`tb_1_.TENANT`

## 过滤关联对象

不仅可以过滤聚合根读对象，关联对象也可以被过滤。

假设`Book`实体继承了`TenantAware`，用法如下

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
List<Author> authors = sqlClient.getEntities.findAll(
    AuthorFetcher.$
        .allScalarFields()
        // highlight-next-line
        .books(
            BookFetcher.$
                .allScalarFields()
        )
);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val books = sqlClient.entities.findAll(
    newFetcher(Author::class).by {
        allScalarFields()
        // highlight-next-line
        books {
            allScalarFields()
        }
    }
);
```

</TabItem>
</Tabs>
或
<Tabs groupId="language">
<TabItem value="java" label="Java(Fluent)">

```java
Fluent fluent = sqlClient.createFluent();
AuthorTable author = new AuthorTable();
List<Author> authors = fluent
    .query(author)
    .select(
        author.fetch(
            AuthorFetcher.$
                .allScalarFields()
                // highlight-next-line
                .books(
                    BookFetcher.$
                        .allScalarFields()
                )
        )
    )
    .execute();
```

</TabItem>
<TabItem value="java-lamda" label="Java(Lambda)">

```java
List<Author> authors = sqlClient
    .createQuery(AuthorTable.class, (q, author) -> {
        return q.select(
            author.fetch(
                AuthorFetcher.$
                    .allScalarFields()
                    // highlight-next-line
                    .books(
                        BookFetcher.$
                            .allScalarFields()
                    )
            )
        );
    })
    .execute();
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val authors = SqlClient
    .createQuery(Author::class) {
        select(
            table.fetchBy {
                allScalarFields()
                // highlight-next-line
                books {
                    allScalarFields()
                }
            }
        )
    }
    .execute()
```

</TabItem>
</Tabs>

这会导致如下两句SQL被生成

1.  查询聚合根
    ```sql
    select 
        tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME, tb_1_.GENDER 
    from AUTHOR as tb_1_
    ```

2.  查询关联对象
    ```sql
    select 
        tb_2_.AUTHOR_ID, 
        tb_1_.ID, 
        tb_1_.TENANT, 
        tb_1_.NAME, 
        tb_1_.EDITION, 
        tb_1_.PRICE 
    from BOOK as tb_1_ 
    inner join BOOK_AUTHOR_MAPPING as tb_2_ 
        on tb_1_.ID = tb_2_.BOOK_ID 
    where 
        tb_2_.AUTHOR_ID in (?, ?, ?, ?, ?) 
    and 
        /* highlight-next-line */
        tb_1_.TENANT = ?
    ```

不难发现，这里使用了对象抓取器。虽然对象抓取器没有对关联属性`Author.books`施加任何[字段级过滤器](../query/fetcher#字段过滤器)，但`Book`类的全局过滤器仍然生效。导致，最终生产的SQL仍然过滤了租户信息。

:::info
这里通过[对象抓取器](./fetcher)演示了关联对象的过滤。事实上，Jimmer提供的[GraphQL](../../spring-graphql)功能同样可以利用全局过滤器过滤关联对象，二者效果一样，不再赘述。
:::

## 过滤器和缓存

前文提到，全局过滤器可以和[对象抓取器](./fetcher)或GraphQL配合使用，用于过滤关联对象。

这表示，不同的操作者，可以看到不同的对象关联。

然而，在[外部缓存](./cache)一文中，我么提到Jimmer支持关联缓存，例如

|key|value|
|---|-----|
|Author.boooks-1|[1, 2, 3]|
|Author.boooks-2|[4, 5, 6]|

这表示，和`id`为`1`的作者相关的书籍是`1`、`2`和`3`，而和`id`为`2`的作者相关的书籍是`4`、`5`和`6`。

这个例子中，`Author.books`这个多对多关联被缓存所描述，然而，所有操作者看到的缓存数据是一样的，这和全局过滤器可以让不同的操作者看到不同的对象关联不相符。

为了，Jimmer支持更高级的缓存功能，和全局过滤器配合，让不同的操作者看到不同的缓存。

### 缓存友好的过滤器

Will come soon

### 参数化缓存

Will come soon

### 参数化缓存一致性

Will come soon